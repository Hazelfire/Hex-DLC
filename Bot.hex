
properties = {
	name: "Hex Deep Learning Code",
	author: "Michael Smith",
	description: "This DLC requires base game to function",
	version: 1.0
}

//Global Constants//

//Game constants
const BOARD_SIZE = 11;

//Network constants
const SIGMOID = true;
const INPUT_SIZE = 122;
const TOTAL_LAYERS = 3;
const LAYER_SIZES = [8, 6, 2];
const PLAYER = 0; //0-player1, 1-player2

//Evolution constants
const GENERATIONS = 5;
const POP_SIZE = 10;
const MUTATION_RATE = 0.05;

let championWeights = []; // Paste weights from saved file here

function init (){
	say("Begin Init");

	~champion = new Network(INPUT_SIZE, LAYER_SIZES, championWeights);

	//Scoring test

	// let pop = new Population();
	// console.log ("Generating members...");
	// pop.populate(POP_SIZE);
	// console.log ("Completed generation");
	// console.log ("Fighting AI's to the death...");
	// score(pop);
	// console.log ("Completed fighting");

	// let i = 0;
	// let high = pop.members[0].fitness;
	// let highIndex = 0;

	// for (let i = 0; i < pop.members.length; i++) {
	// 	if (pop.members[i].fitness >= high) {
	// 		highIndex = i;
	// 		high = pop.members[i].fitness;
	// 	}
	// }

	// console.log("Congratulations AI #" + (highIndex) + "!");
	// console.log("You have won with a score of " + high + "!");

	// champion = pop.members[highIndex].network;

	// console.log("Picked fitness: " + roulettePick(pop).fitness);


	// Node test
	// let weights = [0.25, 0.25, 0];
	// let inputs = [1, 1];

	// let n = new Node(weights);

	// console.log(n.getOutput(inputs));


	//Layer test
	// let weights = [ [0.25, 0.25, 0, 0, 0], [0, 0, 1, 1, 0] ]
	// let input = [1, 1, 1, 1];

	// let l = new Layer(2, weights);

	// console.log(l.getOutput(input));


	// Network test
	// let layers = [2, 1];
	// let weights = [0.25, 0.25, 0, 0, 0, 0, 0, 0.5, 0.5, 0, 0.25, 0.25, 0];
	// let input = [1, 1, 1, 1];

	// let bob = new Network(input.length, layers, weights);

	// console.log(bob.getOutput(input));
	// console.log(bob.getWeights());
}

function main () {
	let board = clone();

	let input = new Array();
	for (let i = 0; i < board.length; i ++) {
		input = input.concat(board[i]);
	}

	//Add player input (0-player1, 1-player2)
	input.push(PLAYER);

	let move = ~champion.getOutput(input);

	//Pick a random move if the AI tries to pick an occupied hex
	if (value(convertOutput(move[0]), convertOutput(move[1])) != 0) {
		let x = rndg();
		let y = rndg();
		return hex(x, y);
	}
	else {
		return findClosestEmptyHex(convertOutput(move[0]), convertOutput(move[1]));
	}
}

function distanceHeuristic(x1, y1, x2, y2){
	return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2))
}

function findClosestEmptyHex(x, y){
	let closestX = 200;
	let closestY = 200;
	let closestDistance = 200;
	
	for (let prospectiveX = 0; prospectiveX < BOARD_SIZE; prospectiveX++){
		for (let prospectiveY = 0; prospectiveY<BOARD_SIZE; prospectiveY++){
			
			if (empty(prospectiveX, prospectiveY)){
				
				if(distanceHeuristic(prospectiveX, prospectiveY, x, y) < closestDistance){
					
					closestX = prospectiveX;
					closestY = prospectiveY;
					closestDistance = distanceHeuristic(prospectiveX, prospectiveY, x, y);
				}
			}
		}
	}
	
	return hex(closestX, closestY)
}

//Network code//

//Node//
function Node(w) {
	this.weights = w;
	// console.log ("Created node with weights: " + this.weights);
}

Node.prototype.getOutput = function(input) {
	this.sum = 0;
	let biasedInputs = new Array();


	//Is this neccesary?
	for (let i = 0; i < input.length; i++) {
		biasedInputs[i] = input[i];
	}

	//Add bias input
	biasedInputs.push(1);

	// console.log("Total inputs: " + biasedInputs.length);
	// console.log(biasedInputs);

	for (let i = 0; i < biasedInputs.length; i++) {
		this.sum += biasedInputs[i] * this.weights[i];
		// console.log("Input: " + biasedInputs[i] + ", Weight: " + this.weights[i]);
		// console.log("Weighted input: " + biasedInputs[i] * this.weights[i]);
		// console.log("Current sum: " + this.sum);
	}


	if (SIGMOID) {
		//Sigmoid activation
		return sigmoid(this.sum);
	}
	else {
		//Binary activation
		if (this.sum >= 0.5) {
			// console.log("Output: 1");
			return 1;
		}
		else {
			// console.log("Output: 0");
			return 0;
		}
	}
};



//Layer//
function Layer(size, weights) {
	this.nodes = new Array();

	for (let i = 0; i < size; i++) {
		this.nodes.push(new Node(weights[i]));
	}

	// console.log("Created layer of size " + size);
}

Layer.prototype.getOutput = function(inputs) {
	let nodeInputs = inputs;
	this.outputs = new Array();
	// console.log("Started processing " + inputs.length + " inputs");
	// console.log("Node count: " + this.nodes.length);

	// console.log("Layer inputs:");
	// console.log(nodeInputs);

	for (let i = 0; i < this.nodes.length; i++) {
		// console.log(i);
		// console.log("Inputing into node " + i);
		// console.log(nodeInputs);
		this.outputs.push(this.nodes[i].getOutput(nodeInputs));
		// console.log(i);
	}

	return this.outputs;
}

Layer.prototype.getSize = function() {
	return this.nodes.length;
};



//Network//
function Network(inputSize, sizes, weights) {
	this.inputSize = inputSize;
	this.sizes = sizes;
	this.layers = new Array();

	this.setWeights(weights);
}

Network.prototype.getOutput = function(input) {
	let inputs = input;

	for(let i = 0; i < this.layers.length; i++) {
		inputs = this.layers[i].getOutput(inputs);
	}

	return inputs;
}

//Returns a 1-dimensional array of all weights for evolution
Network.prototype.getWeights = function() {
	let weightArray = new Array();

	for (let i = 0; i < this.layers.length; i++) {
		for (let j = 0; j < this.layers[i].nodes.length; j++) {
			for (let k = 0; k < this.layers[i].nodes[j].weights.length; k++) {
				weightArray.push(this.layers[i].nodes[j].weights[k]);
			}
		}
	}

	return weightArray;
}

//Set the weights of the network using a 1-d weight array
Network.prototype.setWeights = function(weights) {
	//Convert 1-d array into 3-d array
	let counter = 0;

	let structuredWeights = new Array();
	for (let i = 0; i < this.sizes.length; i ++) {
		structuredWeights.push(new Array());
		// console.log("Creating Layer " + i + " of size " + sizes[i]);

		//Iterate Nodes
		for (let j = 0; j < this.sizes[i]; j++) {
			structuredWeights[i].push(new Array());
			let k = 0; //Weight counter
			let w = 0; //No. of weights per node
			//The amount of weights to assign to each node depends on the size of the previous layer
			if (i == 0) {
				//Set no. of weights to the no. of inputs for the first layer, as there is no previous layer
				w = this.inputSize + 1; //Accounting for bias input
			}
			else {
					w = this.sizes[i - 1] + 1; //Accounting for bias input
			}

			// console.log("Creating node with " + w + " inputs");
			

			for (let k = 0; k < w; k++) {
				structuredWeights[i][j].push(weights[counter]);
				counter++;
			}
		}
	}

	// console.log(structuredWeights);

	//Create a new set of layers with new weights
	this.layers = new Array();

	for (let i = 0; i < this.sizes.length; i++) {
			this.layers.push(new Layer(this.sizes[i], structuredWeights[i]));
	}
}

//Other//
function sigmoid(x) {
	return 1 / (1 + Math.pow(Math.E, -x));
}

//Generates a random weight from -1 to 1 (exclusive)
function generateWeight() {
	return Math.random() * 2 - 1
}

//Converts decimal output from 0-1 to an integer from 0-10
function convertOutput(output) {
	return Math.floor(output * 11);
}